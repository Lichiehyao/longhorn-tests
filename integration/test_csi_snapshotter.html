<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tests.test_csi_snapshotter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tests.test_csi_snapshotter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time
from urllib.parse import urlparse

import pytest
from backupstore import backupstore_s3  # NOQA
from backupstore import set_random_backupstore  # NOQA
from common import RETRY_COUNTS
from common import RETRY_INTERVAL
from common import client  # NOQA
from common import core_api  # NOQA
from common import create_and_wait_pod
from common import create_pvc_spec
from common import create_snapshot
from common import csi_pv  # NOQA
from common import find_backup
from common import get_custom_object_api_client
from common import get_pod_data_md5sum
from common import pod_make  # NOQA
from common import prepare_pod_with_data_in_mb
from common import pvc  # NOQA
from common import volume_name  # NOQA
from common import wait_for_backup_completion
from common import wait_for_backup_delete
from common import wait_for_volume_detached
from common import wait_for_volume_restoration_completed
from kubernetes.client.rest import ApiException


@pytest.fixture
def volumesnapshotclass(request):
    class VolumeSnapshotClassFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshotclass(name, deletepolicy, snapshot_type=None):
            manifest = {
                &#39;kind&#39;: &#39;VolumeSnapshotClass&#39;,
                &#39;apiVersion&#39;: &#39;snapshot.storage.k8s.io/v1beta1&#39;,
                &#39;metadata&#39;: {
                  &#39;name&#39;: name
                },
                &#39;driver&#39;: &#39;driver.longhorn.io&#39;,
                &#39;deletionPolicy&#39;: deletepolicy
            }

            if snapshot_type is not None:
                manifest.update({&#39;parameters&#39;: {&#39;type&#39;: snapshot_type}})

            VolumeSnapshotClassFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            manifest_api_version = manifest[&#34;apiVersion&#34;]

            api_group = urlparse(manifest_api_version).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest_api_version).path.split(&#34;/&#34;)[1]
            plural = &#34;volumesnapshotclasses&#34;

            try:
                api.create_cluster_custom_object(group=api_group,
                                                 version=api_version,
                                                 plural=plural,
                                                 body=manifest)
            except ApiException as e:
                print(&#34;exception creating volumesnapshotclass %s\n&#34; % e)

            return manifest

    yield VolumeSnapshotClassFactory.create_volumesnapshotclass

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotClassFactory.manifests:
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        plural = &#34;volumesnapshotclasses&#34;

        try:
            api.delete_cluster_custom_object(group=api_group,
                                             version=api_version,
                                             plural=plural,
                                             name=name)
        except ApiException as e:
            assert e.status == 404


@pytest.fixture
def volumesnapshot(request):
    class VolumeSnapshotFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshot(name,
                                  namespace,
                                  volumesnapshotclass_name,
                                  source_type,
                                  source_name):
            manifest = {
                &#39;apiVersion&#39;: &#39;snapshot.storage.k8s.io/v1beta1&#39;,
                &#39;kind&#39;: &#39;VolumeSnapshot&#39;,
                &#39;metadata&#39;: {
                  &#39;name&#39;: name,
                  &#39;namespace&#39;: namespace,
                },
                &#39;spec&#39;: {
                  &#39;volumeSnapshotClassName&#39;: volumesnapshotclass_name,
                  &#39;source&#39;: {
                    source_type: source_name
                  }
                }
            }

            VolumeSnapshotFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
            name = manifest[&#34;metadata&#34;][&#34;name&#34;]
            plural = &#34;volumesnapshots&#34;

            try:
                api.create_namespaced_custom_object(group=api_group,
                                                    version=api_version,
                                                    namespace=namespace,
                                                    plural=plural,
                                                    body=manifest)
            except ApiException as e:
                print(&#34;exception create volumesnapshot %s\n&#34; % e)

            for i in range(RETRY_COUNTS):
                status = \
                    api.get_namespaced_custom_object_status(
                            group=api_group,
                            version=api_version,
                            namespace=namespace,
                            plural=plural,
                            name=name)
                if &#34;status&#34; in status:
                    if &#34;boundVolumeSnapshotContentName&#34; in status[&#34;status&#34;]:
                        break
                time.sleep(RETRY_INTERVAL)

            return status

    yield VolumeSnapshotFactory.create_volumesnapshot

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotFactory.manifests:
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        namespace = manifest[&#34;metadata&#34;][&#34;namespace&#34;]
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        plural = &#34;volumesnapshots&#34;

        try:
            api.delete_namespaced_custom_object(group=api_group,
                                                version=api_version,
                                                namespace=namespace,
                                                plural=plural,
                                                name=name)
        except ApiException as e:
            assert e.status == 404


@pytest.fixture
def volumesnapshotcontent(request):
    class VolumeSnapshotContentFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshotcontent(name,
                                         volumesnapshotclass_name,
                                         delete_policy,
                                         snapshot_handle,
                                         volumesnapshot_ref_name,
                                         volumesnapshot_ref_namespace):
            manifest = {
                &#34;apiVersion&#34;: &#34;snapshot.storage.k8s.io/v1beta1&#34;,
                &#34;kind&#34;: &#34;VolumeSnapshotContent&#34;,
                &#34;metadata&#34;: {
                  &#34;name&#34;: name,
                },
                &#34;spec&#34;: {
                  &#34;volumeSnapshotClassName&#34;: volumesnapshotclass_name,
                  &#34;driver&#34;: &#34;driver.longhorn.io&#34;,
                  &#34;deletionPolicy&#34;: delete_policy,
                  &#34;source&#34;: {
                    &#34;snapshotHandle&#34;: snapshot_handle
                  },
                  &#34;volumeSnapshotRef&#34;: {
                    &#34;name&#34;: volumesnapshot_ref_name,
                    &#34;namespace&#34;: volumesnapshot_ref_namespace
                  }
                }
              }

            VolumeSnapshotContentFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
            name = manifest[&#34;metadata&#34;][&#34;name&#34;]
            plural = &#34;volumesnapshotcontents&#34;

            try:
                api.create_cluster_custom_object(group=api_group,
                                                 version=api_version,
                                                 plural=plural,
                                                 body=manifest)
            except ApiException as e:
                print(&#34;exception create volumesnapshotcontent %s\n&#34; % e)

            for i in range(RETRY_COUNTS):
                status = \
                    api.get_cluster_custom_object_status(group=api_group,
                                                         version=api_version,
                                                         plural=plural,
                                                         name=name)
                if &#34;status&#34; in status:
                    if status[&#34;status&#34;][&#34;readyToUse&#34;] is True:
                        break
                time.sleep(RETRY_INTERVAL)

            return status

    yield VolumeSnapshotContentFactory.create_volumesnapshotcontent

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotContentFactory.manifests:
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        plural = &#34;volumesnapshotcontents&#34;

        try:
            api.delete_cluster_custom_object(group=api_group,
                                             version=api_version,
                                             plural=plural,
                                             name=name)
        except ApiException as e:
            assert e.status == 404


def get_volumesnapshotcontent(volumesnapshot_uid):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshotcontents&#34;

    volumesnapshotcontents = \
        api.list_cluster_custom_object(group=api_group,
                                       version=api_version,
                                       plural=plural)

    for v in volumesnapshotcontents[&#34;items&#34;]:
        if v[&#34;spec&#34;][&#34;volumeSnapshotRef&#34;][&#34;uid&#34;] == volumesnapshot_uid:
            break

    return v


def delete_volumesnapshot(name, namespace):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshots&#34;

    try:
        api.delete_namespaced_custom_object(group=api_group,
                                            version=api_version,
                                            namespace=namespace,
                                            plural=plural,
                                            name=name)
    except ApiException as e:
        assert e.status == 404


def wait_for_volumesnapshot_ready(volumesnapshot_name, namespace):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshots&#34;

    for i in range(RETRY_COUNTS):
        v = api.get_namespaced_custom_object_status(group=api_group,
                                                    version=api_version,
                                                    namespace=namespace,
                                                    plural=plural,
                                                    name=volumesnapshot_name)

        if v[&#34;status&#34;][&#34;readyToUse&#34;] is True:
            break

        time.sleep(RETRY_INTERVAL)

    assert v[&#34;status&#34;][&#34;readyToUse&#34;] is True
    return v


def restore_csi_volume_snapshot(core_api, client, csivolsnap, pvc_name, pvc_request_storage_size): # NOQA
    restore_pvc = {
        &#39;apiVersion&#39;: &#39;v1&#39;,
        &#39;kind&#39;: &#39;PersistentVolumeClaim&#39;,
        &#39;metadata&#39;: {
            &#39;name&#39;: pvc_name
        },
        &#39;spec&#39;: {
            &#39;accessModes&#39;: [
                &#39;ReadWriteOnce&#39;
            ],
            &#39;resources&#39;: {
                &#39;requests&#39;: {
                    &#39;storage&#39;: pvc_request_storage_size
                }
            },
            &#39;storageClassName&#39;: &#39;longhorn&#39;,
            &#39;dataSource&#39;: {
                 &#39;kind&#39;: &#39;VolumeSnapshot&#39;,
                 &#39;apiGroup&#39;: &#39;snapshot.storage.k8s.io&#39;,
                 &#39;name&#39;: csivolsnap[&#34;metadata&#34;][&#34;name&#34;]
             }
        }
    }

    core_api.create_namespaced_persistent_volume_claim(body=restore_pvc,
                                                       namespace=&#39;default&#39;)

    restore_volume_name = None
    restore_pvc_name = restore_pvc[&#34;metadata&#34;][&#34;name&#34;]
    for i in range(RETRY_COUNTS):
        restore_pvc = \
            core_api.read_namespaced_persistent_volume_claim(
                name=restore_pvc_name,
                namespace=&#34;default&#34;)

        if restore_pvc.spec.volume_name is not None:
            restore_volume_name = restore_pvc.spec.volume_name
            break

        time.sleep(RETRY_INTERVAL)

    assert restore_volume_name is not None

    wait_for_volume_restoration_completed(client, restore_volume_name)
    wait_for_volume_detached(client, restore_volume_name)

    return restore_pvc


@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True), (&#34;Retain&#34;, False)]) # NOQA
def test_csi_volumesnapshot_basic(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted,
                                  csi_snapshot_type=None): # NOQA
    &#34;&#34;&#34;
    Test creation / restoration / deletion of a backup via the csi snapshotter

    Context:

    We want to allow the user to programmatically create/restore/delete
    longhorn backups via the csi snapshot mechanism
    ref: https://kubernetes.io/docs/concepts/storage/volume-snapshots/

    Setup:

    1. Make sure your cluster contains the below crds
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/client/config/crd
    2. Make sure your cluster contains the snapshot controller
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/deploy/kubernetes/snapshot-controller

    Steps:

    def csi_volumesnapshot_creation_test(snapshotClass=longhorn|custom):
    1. create volume(1)
    2. write data to volume(1)
    3. create a kubernetes `VolumeSnapshot` object
       the `VolumeSnapshot.uuid` will be used to identify a
       **longhorn snapshot** and the associated `VolumeSnapshotContent` object
    4. check creation of a new longhorn snapshot named `snapshot-uuid`
    5. check for `VolumeSnapshotContent` named `snapcontent-uuid`
    6. wait for `VolumeSnapshotContent.readyToUse` flag to be set to **true**
    7. check for backup existance on the backupstore

    # the csi snapshot restore sets the fromBackup field same as
    # the StorageClass based restore approach.
    def csi_volumesnapshot_restore_test():
    8. create a `PersistentVolumeClaim` object where the `dataSource` field
       references the `VolumeSnapshot` object by name
    9. verify creation of a new volume(2) bound to the pvc created in step(8)
    10. verify data of new volume(2) equals data
        from backup (ie old data above)

    # default longhorn snapshot class is set to Delete
    # add a second test with a custom snapshot class with deletionPolicy
    # set to Retain you can reuse these methods for that and other tests
    def csi_volumesnapshot_deletion_test(deletionPolicy=&#39;Delete|Retain&#39;):
    11. delete `VolumeSnapshot` object
    12. if deletionPolicy == Delete:
        13. verify deletion of `VolumeSnapshot` and
            `VolumeSnapshotContent` objects
        14. verify deletion of backup from backupstore
    12. if deletionPolicy == Retain:
        13. verify deletion of `VolumeSnapshot`
        14. verify retention of `VolumeSnapshotContent`
            and backup on backupstore

    15. cleanup
    &#34;&#34;&#34;

    csisnapclass = \
        volumesnapshotclass(name=&#34;snapshotclass&#34;,
                            deletepolicy=volsnapshotclass_delete_policy,
                            snapshot_type=csi_snapshot_type)

    pod_name, pv_name, pvc_name, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api,
                                    csi_pv, pvc, pod_make,
                                    volume_name,
                                    data_path=&#34;/data/test&#34;)

    # Create volumeSnapshot test
    csivolsnap = volumesnapshot(volume_name + &#34;-volumesnapshot&#34;,
                                &#34;default&#34;,
                                csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                                &#34;persistentVolumeClaimName&#34;,
                                pvc_name)

    volume = client.by_id_volume(volume_name)

    for i in range(RETRY_COUNTS):
        snapshots = volume.snapshotList()
        if len(snapshots) == 2:
            break
        time.sleep(RETRY_INTERVAL)

    lh_snapshot = None
    snapshots = volume.snapshotList()
    for snapshot in snapshots:
        if snapshot[&#34;name&#34;] == &#34;snapshot-&#34; + csivolsnap[&#34;metadata&#34;][&#34;uid&#34;]:
            lh_snapshot = snapshot
    assert lh_snapshot is not None

    wait_for_volumesnapshot_ready(csivolsnap[&#34;metadata&#34;][&#34;name&#34;],
                                  csivolsnap[&#34;metadata&#34;][&#34;namespace&#34;])

    bv1, b = find_backup(client, volume_name, lh_snapshot[&#34;name&#34;])

    assert b[&#34;snapshotName&#34;] == lh_snapshot[&#34;name&#34;]

    restore_pvc_name = pvc[&#34;metadata&#34;][&#34;name&#34;] + &#34;-restore&#34;
    restore_pvc_size = pvc[&#34;spec&#34;][&#34;resources&#34;][&#34;requests&#34;][&#34;storage&#34;]

    restore_csi_volume_snapshot(core_api,
                                client,
                                csivolsnap,
                                restore_pvc_name,
                                restore_pvc_size)

    restore_pod = pod_make()
    restore_pod_name = restore_pod[&#34;metadata&#34;][&#34;name&#34;]
    restore_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(restore_pvc_name)]

    create_and_wait_pod(core_api, restore_pod)
    restore_md5sum = \
        get_pod_data_md5sum(core_api, restore_pod_name, path=&#34;/data/test&#34;)
    assert restore_md5sum == md5sum

    # Delete volumeSnapshot test
    delete_volumesnapshot(csivolsnap[&#34;metadata&#34;][&#34;name&#34;], &#34;default&#34;)

    if backup_is_deleted is False:
        find_backup(client, volume_name, b[&#34;snapshotName&#34;])
    else:
        wait_for_backup_delete(client, volume_name, b[&#34;name&#34;])


@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True), (&#34;Retain&#34;, False)]) # NOQA
def test_csi_volumesnapshot_restore_existing_backup(set_random_backupstore, # NOQA
                                                    client, # NOQA
                                                    core_api, # NOQA
                                                    volume_name, # NOQA
                                                    csi_pv, # NOQA
                                                    pvc, # NOQA
                                                    pod_make, # NOQA
                                                    volumesnapshotclass, # NOQA
                                                    volumesnapshotcontent,
                                                    volumesnapshot, # NOQA
                                                    volsnapshotclass_delete_policy, # NOQA
                                                    backup_is_deleted): # NOQA
    &#34;&#34;&#34;
    Test retention of a backup while deleting the associated `VolumeSnapshot`
    via the csi snapshotter

    Context:

    We want to allow the user to programmatically create/restore/delete
    longhorn backups via the csi snapshot mechanism
    ref: https://kubernetes.io/docs/concepts/storage/volume-snapshots/

    Setup:

    1. Make sure your cluster contains the below crds
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/client/config/crd
    2. Make sure your cluster contains the snapshot controller
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/deploy/kubernetes/snapshot-controller

    Steps:

    1. create new snapshotClass with deletionPolicy set to Retain
    2. call csi_volumesnapshot_creation_test(snapshotClass=custom)
    3. call csi_volumesnapshot_restore_test()
    4. call csi_volumesnapshot_deletion_test(deletionPolicy=&#39;Retain&#39;):
    5. cleanup
    &#34;&#34;&#34;
    csisnapclass = \
        volumesnapshotclass(name=&#34;snapshotclass&#34;,
                            deletepolicy=volsnapshotclass_delete_policy)

    pod_name, pv_name, pvc_name, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api,
                                    csi_pv, pvc, pod_make,
                                    volume_name,
                                    data_path=&#34;/data/test&#34;)

    volume = client.by_id_volume(volume_name)
    snap = create_snapshot(client, volume_name)
    volume.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client, volume_name, snap.name)
    bv, b = find_backup(client, volume_name, snap.name)

    csivolsnap_name = volume_name + &#34;-volumesnapshot&#34;
    csivolsnap_namespace = &#34;default&#34;

    volsnapcontent = \
        volumesnapshotcontent(&#34;volsnapcontent&#34;,
                              csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                              &#34;Delete&#34;,
                              &#34;bs://&#34; + volume_name + &#34;/&#34; + b.name,
                              csivolsnap_name,
                              csivolsnap_namespace)

    csivolsnap = volumesnapshot(csivolsnap_name,
                                csivolsnap_namespace,
                                csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                                &#34;volumeSnapshotContentName&#34;,
                                volsnapcontent[&#34;metadata&#34;][&#34;name&#34;])

    restore_pvc_name = pvc[&#34;metadata&#34;][&#34;name&#34;] + &#34;-restore&#34;
    restore_pvc_size = pvc[&#34;spec&#34;][&#34;resources&#34;][&#34;requests&#34;][&#34;storage&#34;]

    restore_csi_volume_snapshot(core_api,
                                client,
                                csivolsnap,
                                restore_pvc_name,
                                restore_pvc_size)

    restore_pod = pod_make()
    restore_pod_name = restore_pod[&#34;metadata&#34;][&#34;name&#34;]
    restore_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(restore_pvc_name)]

    create_and_wait_pod(core_api, restore_pod)
    restore_md5sum = \
        get_pod_data_md5sum(core_api, restore_pod_name, path=&#34;/data/test&#34;)

    assert restore_md5sum == md5sum

    # Delete volumeSnapshot test
    delete_volumesnapshot(csivolsnap[&#34;metadata&#34;][&#34;name&#34;], &#34;default&#34;)

    if backup_is_deleted is False:
        find_backup(client, volume_name, b[&#34;snapshotName&#34;])
    else:
        wait_for_backup_delete(client, volume_name, b[&#34;name&#34;])


@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True)]) # NOQA
def test_csi_snapshot_with_bak_param(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=bak
      - longhorn-backup (type=bak)

    Test the extend CSI snapshot type=bak support to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC/Workload for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Create VolumeSnapshot with class longhorn-backup
        - Should have backup generated
    2. Test create new volume from CSI snapshot
        - Create PVC from VolumeSnapshot generated in step 1
        - Attach PVC and verify data
    3. Test delete CSI snapshot
        - Delete VolumeSnapshot
        - The backup should deleted as well
    &#34;&#34;&#34;
    test_csi_volumesnapshot_basic(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted, # NOQA
                                  csi_snapshot_type=&#39;bak&#39;)


@pytest.mark.skip(reason=&#34;TODO&#34;) # NOQA
def test_csi_snapshot_with_snap_param(client, volume_name): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=snap
      - longhorn-snapshot (type=snap)

    Test the extend CSI snapshot type=snap support to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC/Workload for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Volume is in detached state
            - Scale down the workload
            - Create VolumeSnapshot with class longhorn-snap
            - Verify that the volumesnapshot object is not ready
        - Volume is in attached state
            - Scale up the workload
            - Verify the Longhorn snapshot generated
    2. Test create new volume from CSI snapshot
        - Create volume from longhorn-snapshot
            - Source volume is attached &amp;&amp; Longhorn snapshot exist
                - Create PVC from snapshot generated from step 1
                - Attach the PVC and verify data
            - Source volume is detached
                - Scale down the workload
                - Create PVC from VolumeSnapshot generated from step 1
                - Verify PVC provision failed
            - Source volume is attached &amp;&amp; Longhorn snapshot doesn’t exist
                - Scale up the workload
                - Use VolumeSnapshotContent.snapshotHandle to
                  specify Longhorn snapshot generated in step 1
                - Delete the Longhorn snapshot
                - Create PVC from VolumeSnapshot generated from step 1
                - PVC should be stuck in provisioning state
    3. Test delete CSI snapshot
        - Type is snap
            - volume is attached &amp;&amp; snapshot doesn’t exist
                - Delete the VolumeSnapshot
                - VolumeSnapshot is deleted
            - volume is attached &amp;&amp; snapshot exist
                - Verify the creation of Longhorn snapshot with the name in
                  the field VolumeSnapshotContent.snapshotHandle
                - Delete the VolumeSnapshot
                - Verify that Longhorn snapshot is removed or marked as removed
                - Verify that the VolumeSnapshot is deleted.
            - volume is detached
                - Delete the VolumeSnapshot
                - Verify that VolumeSnapshot is stuck in deleting
    &#34;&#34;&#34;

@pytest.mark.skip(reason=&#34;TODO&#34;) # NOQA
def test_csi_snapshot_with_invalid_param(client, volume_name): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=invalid
      - invalid (type=invalid)

    Test the extend CSI snapshot type=invalid behavior to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Create VolumeSnapshot with class invalid
        - Verify that the volumesnapshot object is not ready
    &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tests.test_csi_snapshotter.delete_volumesnapshot"><code class="name flex">
<span>def <span class="ident">delete_volumesnapshot</span></span>(<span>name, namespace)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_volumesnapshot(name, namespace):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshots&#34;

    try:
        api.delete_namespaced_custom_object(group=api_group,
                                            version=api_version,
                                            namespace=namespace,
                                            plural=plural,
                                            name=name)
    except ApiException as e:
        assert e.status == 404</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.get_volumesnapshotcontent"><code class="name flex">
<span>def <span class="ident">get_volumesnapshotcontent</span></span>(<span>volumesnapshot_uid)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volumesnapshotcontent(volumesnapshot_uid):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshotcontents&#34;

    volumesnapshotcontents = \
        api.list_cluster_custom_object(group=api_group,
                                       version=api_version,
                                       plural=plural)

    for v in volumesnapshotcontents[&#34;items&#34;]:
        if v[&#34;spec&#34;][&#34;volumeSnapshotRef&#34;][&#34;uid&#34;] == volumesnapshot_uid:
            break

    return v</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.restore_csi_volume_snapshot"><code class="name flex">
<span>def <span class="ident">restore_csi_volume_snapshot</span></span>(<span>core_api, client, csivolsnap, pvc_name, pvc_request_storage_size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_csi_volume_snapshot(core_api, client, csivolsnap, pvc_name, pvc_request_storage_size): # NOQA
    restore_pvc = {
        &#39;apiVersion&#39;: &#39;v1&#39;,
        &#39;kind&#39;: &#39;PersistentVolumeClaim&#39;,
        &#39;metadata&#39;: {
            &#39;name&#39;: pvc_name
        },
        &#39;spec&#39;: {
            &#39;accessModes&#39;: [
                &#39;ReadWriteOnce&#39;
            ],
            &#39;resources&#39;: {
                &#39;requests&#39;: {
                    &#39;storage&#39;: pvc_request_storage_size
                }
            },
            &#39;storageClassName&#39;: &#39;longhorn&#39;,
            &#39;dataSource&#39;: {
                 &#39;kind&#39;: &#39;VolumeSnapshot&#39;,
                 &#39;apiGroup&#39;: &#39;snapshot.storage.k8s.io&#39;,
                 &#39;name&#39;: csivolsnap[&#34;metadata&#34;][&#34;name&#34;]
             }
        }
    }

    core_api.create_namespaced_persistent_volume_claim(body=restore_pvc,
                                                       namespace=&#39;default&#39;)

    restore_volume_name = None
    restore_pvc_name = restore_pvc[&#34;metadata&#34;][&#34;name&#34;]
    for i in range(RETRY_COUNTS):
        restore_pvc = \
            core_api.read_namespaced_persistent_volume_claim(
                name=restore_pvc_name,
                namespace=&#34;default&#34;)

        if restore_pvc.spec.volume_name is not None:
            restore_volume_name = restore_pvc.spec.volume_name
            break

        time.sleep(RETRY_INTERVAL)

    assert restore_volume_name is not None

    wait_for_volume_restoration_completed(client, restore_volume_name)
    wait_for_volume_detached(client, restore_volume_name)

    return restore_pvc</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.test_csi_snapshot_with_bak_param"><code class="name flex">
<span>def <span class="ident">test_csi_snapshot_with_bak_param</span></span>(<span>set_random_backupstore, volumesnapshotclass, volumesnapshot, client, core_api, volume_name, csi_pv, pvc, pod_make, volsnapshotclass_delete_policy, backup_is_deleted)</span>
</code></dt>
<dd>
<div class="desc"><p>Context:</p>
<p>After deploy the CSI snapshot CRDs, Controller at
<a href="https://longhorn.io/docs/1.2.3/snapshots-and-backups/">https://longhorn.io/docs/1.2.3/snapshots-and-backups/</a>
csi-snapshot-support/enable-csi-snapshot-support/</p>
<p>Create VolumeSnapshotClass with type=bak
- longhorn-backup (type=bak)</p>
<p>Test the extend CSI snapshot type=bak support to Longhorn snapshot</p>
<p>Steps:</p>
<ol>
<li>Create Longhorn volume test-vol<ul>
<li>Size 5GB</li>
<li>Create PV/PVC/Workload for the Longhorn volume</li>
<li>Write data into volume</li>
<li>Setup backup store</li>
</ul>
</li>
<li>Test create CSI snapshot<ul>
<li>Create VolumeSnapshot with class longhorn-backup</li>
<li>Should have backup generated</li>
</ul>
</li>
<li>Test create new volume from CSI snapshot<ul>
<li>Create PVC from VolumeSnapshot generated in step 1</li>
<li>Attach PVC and verify data</li>
</ul>
</li>
<li>Test delete CSI snapshot<ul>
<li>Delete VolumeSnapshot</li>
<li>The backup should deleted as well</li>
</ul>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True)]) # NOQA
def test_csi_snapshot_with_bak_param(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=bak
      - longhorn-backup (type=bak)

    Test the extend CSI snapshot type=bak support to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC/Workload for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Create VolumeSnapshot with class longhorn-backup
        - Should have backup generated
    2. Test create new volume from CSI snapshot
        - Create PVC from VolumeSnapshot generated in step 1
        - Attach PVC and verify data
    3. Test delete CSI snapshot
        - Delete VolumeSnapshot
        - The backup should deleted as well
    &#34;&#34;&#34;
    test_csi_volumesnapshot_basic(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted, # NOQA
                                  csi_snapshot_type=&#39;bak&#39;)</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.test_csi_snapshot_with_invalid_param"><code class="name flex">
<span>def <span class="ident">test_csi_snapshot_with_invalid_param</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Context:</p>
<p>After deploy the CSI snapshot CRDs, Controller at
<a href="https://longhorn.io/docs/1.2.3/snapshots-and-backups/">https://longhorn.io/docs/1.2.3/snapshots-and-backups/</a>
csi-snapshot-support/enable-csi-snapshot-support/</p>
<p>Create VolumeSnapshotClass with type=invalid
- invalid (type=invalid)</p>
<p>Test the extend CSI snapshot type=invalid behavior to Longhorn snapshot</p>
<p>Steps:</p>
<ol>
<li>Create Longhorn volume test-vol<ul>
<li>Size 5GB</li>
<li>Create PV/PVC for the Longhorn volume</li>
<li>Write data into volume</li>
<li>Setup backup store</li>
</ul>
</li>
<li>Test create CSI snapshot<ul>
<li>Create VolumeSnapshot with class invalid</li>
<li>Verify that the volumesnapshot object is not ready</li>
</ul>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.skip(reason=&#34;TODO&#34;) # NOQA
def test_csi_snapshot_with_invalid_param(client, volume_name): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=invalid
      - invalid (type=invalid)

    Test the extend CSI snapshot type=invalid behavior to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Create VolumeSnapshot with class invalid
        - Verify that the volumesnapshot object is not ready
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.test_csi_snapshot_with_snap_param"><code class="name flex">
<span>def <span class="ident">test_csi_snapshot_with_snap_param</span></span>(<span>client, volume_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Context:</p>
<p>After deploy the CSI snapshot CRDs, Controller at
<a href="https://longhorn.io/docs/1.2.3/snapshots-and-backups/">https://longhorn.io/docs/1.2.3/snapshots-and-backups/</a>
csi-snapshot-support/enable-csi-snapshot-support/</p>
<p>Create VolumeSnapshotClass with type=snap
- longhorn-snapshot (type=snap)</p>
<p>Test the extend CSI snapshot type=snap support to Longhorn snapshot</p>
<p>Steps:</p>
<ol>
<li>Create Longhorn volume test-vol<ul>
<li>Size 5GB</li>
<li>Create PV/PVC/Workload for the Longhorn volume</li>
<li>Write data into volume</li>
<li>Setup backup store</li>
</ul>
</li>
<li>Test create CSI snapshot<ul>
<li>Volume is in detached state<ul>
<li>Scale down the workload</li>
<li>Create VolumeSnapshot with class longhorn-snap</li>
<li>Verify that the volumesnapshot object is not ready</li>
</ul>
</li>
<li>Volume is in attached state<ul>
<li>Scale up the workload</li>
<li>Verify the Longhorn snapshot generated</li>
</ul>
</li>
</ul>
</li>
<li>Test create new volume from CSI snapshot<ul>
<li>Create volume from longhorn-snapshot<ul>
<li>Source volume is attached &amp;&amp; Longhorn snapshot exist<ul>
<li>Create PVC from snapshot generated from step 1</li>
<li>Attach the PVC and verify data</li>
</ul>
</li>
<li>Source volume is detached<ul>
<li>Scale down the workload</li>
<li>Create PVC from VolumeSnapshot generated from step 1</li>
<li>Verify PVC provision failed</li>
</ul>
</li>
<li>Source volume is attached &amp;&amp; Longhorn snapshot doesn’t exist<ul>
<li>Scale up the workload</li>
<li>Use VolumeSnapshotContent.snapshotHandle to
specify Longhorn snapshot generated in step 1</li>
<li>Delete the Longhorn snapshot</li>
<li>Create PVC from VolumeSnapshot generated from step 1</li>
<li>PVC should be stuck in provisioning state</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Test delete CSI snapshot<ul>
<li>Type is snap<ul>
<li>volume is attached &amp;&amp; snapshot doesn’t exist<ul>
<li>Delete the VolumeSnapshot</li>
<li>VolumeSnapshot is deleted</li>
</ul>
</li>
<li>volume is attached &amp;&amp; snapshot exist<ul>
<li>Verify the creation of Longhorn snapshot with the name in
the field VolumeSnapshotContent.snapshotHandle</li>
<li>Delete the VolumeSnapshot</li>
<li>Verify that Longhorn snapshot is removed or marked as removed</li>
<li>Verify that the VolumeSnapshot is deleted.</li>
</ul>
</li>
<li>volume is detached<ul>
<li>Delete the VolumeSnapshot</li>
<li>Verify that VolumeSnapshot is stuck in deleting</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.skip(reason=&#34;TODO&#34;) # NOQA
def test_csi_snapshot_with_snap_param(client, volume_name): # NOQA
    &#34;&#34;&#34;
    Context:

    After deploy the CSI snapshot CRDs, Controller at
    https://longhorn.io/docs/1.2.3/snapshots-and-backups/
    csi-snapshot-support/enable-csi-snapshot-support/

    Create VolumeSnapshotClass with type=snap
      - longhorn-snapshot (type=snap)

    Test the extend CSI snapshot type=snap support to Longhorn snapshot

    Steps:

    0. Create Longhorn volume test-vol
        - Size 5GB
        - Create PV/PVC/Workload for the Longhorn volume
        - Write data into volume
        - Setup backup store
    1. Test create CSI snapshot
        - Volume is in detached state
            - Scale down the workload
            - Create VolumeSnapshot with class longhorn-snap
            - Verify that the volumesnapshot object is not ready
        - Volume is in attached state
            - Scale up the workload
            - Verify the Longhorn snapshot generated
    2. Test create new volume from CSI snapshot
        - Create volume from longhorn-snapshot
            - Source volume is attached &amp;&amp; Longhorn snapshot exist
                - Create PVC from snapshot generated from step 1
                - Attach the PVC and verify data
            - Source volume is detached
                - Scale down the workload
                - Create PVC from VolumeSnapshot generated from step 1
                - Verify PVC provision failed
            - Source volume is attached &amp;&amp; Longhorn snapshot doesn’t exist
                - Scale up the workload
                - Use VolumeSnapshotContent.snapshotHandle to
                  specify Longhorn snapshot generated in step 1
                - Delete the Longhorn snapshot
                - Create PVC from VolumeSnapshot generated from step 1
                - PVC should be stuck in provisioning state
    3. Test delete CSI snapshot
        - Type is snap
            - volume is attached &amp;&amp; snapshot doesn’t exist
                - Delete the VolumeSnapshot
                - VolumeSnapshot is deleted
            - volume is attached &amp;&amp; snapshot exist
                - Verify the creation of Longhorn snapshot with the name in
                  the field VolumeSnapshotContent.snapshotHandle
                - Delete the VolumeSnapshot
                - Verify that Longhorn snapshot is removed or marked as removed
                - Verify that the VolumeSnapshot is deleted.
            - volume is detached
                - Delete the VolumeSnapshot
                - Verify that VolumeSnapshot is stuck in deleting
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.test_csi_volumesnapshot_basic"><code class="name flex">
<span>def <span class="ident">test_csi_volumesnapshot_basic</span></span>(<span>set_random_backupstore, volumesnapshotclass, volumesnapshot, client, core_api, volume_name, csi_pv, pvc, pod_make, volsnapshotclass_delete_policy, backup_is_deleted, csi_snapshot_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Test creation / restoration / deletion of a backup via the csi snapshotter</p>
<p>Context:</p>
<p>We want to allow the user to programmatically create/restore/delete
longhorn backups via the csi snapshot mechanism
ref: <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">https://kubernetes.io/docs/concepts/storage/volume-snapshots/</a></p>
<p>Setup:</p>
<ol>
<li>Make sure your cluster contains the below crds
<a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a>
/tree/master/client/config/crd</li>
<li>Make sure your cluster contains the snapshot controller
<a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a>
/tree/master/deploy/kubernetes/snapshot-controller</li>
</ol>
<p>Steps:</p>
<p>def csi_volumesnapshot_creation_test(snapshotClass=longhorn|custom):
1. create volume(1)
2. write data to volume(1)
3. create a kubernetes <code>VolumeSnapshot</code> object
the <code>VolumeSnapshot.uuid</code> will be used to identify a
<strong>longhorn snapshot</strong> and the associated <code>VolumeSnapshotContent</code> object
4. check creation of a new longhorn snapshot named <code>snapshot-uuid</code>
5. check for <code>VolumeSnapshotContent</code> named <code>snapcontent-uuid</code>
6. wait for <code>VolumeSnapshotContent.readyToUse</code> flag to be set to <strong>true</strong>
7. check for backup existance on the backupstore</p>
<h1 id="the-csi-snapshot-restore-sets-the-frombackup-field-same-as">the csi snapshot restore sets the fromBackup field same as</h1>
<h1 id="the-storageclass-based-restore-approach">the StorageClass based restore approach.</h1>
<p>def csi_volumesnapshot_restore_test():
8. create a <code>PersistentVolumeClaim</code> object where the <code>dataSource</code> field
references the <code>VolumeSnapshot</code> object by name
9. verify creation of a new volume(2) bound to the pvc created in step(8)
10. verify data of new volume(2) equals data
from backup (ie old data above)</p>
<h1 id="default-longhorn-snapshot-class-is-set-to-delete">default longhorn snapshot class is set to Delete</h1>
<h1 id="add-a-second-test-with-a-custom-snapshot-class-with-deletionpolicy">add a second test with a custom snapshot class with deletionPolicy</h1>
<h1 id="set-to-retain-you-can-reuse-these-methods-for-that-and-other-tests">set to Retain you can reuse these methods for that and other tests</h1>
<p>def csi_volumesnapshot_deletion_test(deletionPolicy='Delete|Retain'):
11. delete <code>VolumeSnapshot</code> object
12. if deletionPolicy == Delete:
13. verify deletion of <code>VolumeSnapshot</code> and
<code>VolumeSnapshotContent</code> objects
14. verify deletion of backup from backupstore
12. if deletionPolicy == Retain:
13. verify deletion of <code>VolumeSnapshot</code>
14. verify retention of <code>VolumeSnapshotContent</code>
and backup on backupstore</p>
<ol>
<li>cleanup</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True), (&#34;Retain&#34;, False)]) # NOQA
def test_csi_volumesnapshot_basic(set_random_backupstore, # NOQA
                                  volumesnapshotclass, # NOQA
                                  volumesnapshot, # NOQA
                                  client, # NOQA
                                  core_api, # NOQA
                                  volume_name, # NOQA
                                  csi_pv, # NOQA
                                  pvc, # NOQA
                                  pod_make, # NOQA
                                  volsnapshotclass_delete_policy, # NOQA
                                  backup_is_deleted,
                                  csi_snapshot_type=None): # NOQA
    &#34;&#34;&#34;
    Test creation / restoration / deletion of a backup via the csi snapshotter

    Context:

    We want to allow the user to programmatically create/restore/delete
    longhorn backups via the csi snapshot mechanism
    ref: https://kubernetes.io/docs/concepts/storage/volume-snapshots/

    Setup:

    1. Make sure your cluster contains the below crds
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/client/config/crd
    2. Make sure your cluster contains the snapshot controller
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/deploy/kubernetes/snapshot-controller

    Steps:

    def csi_volumesnapshot_creation_test(snapshotClass=longhorn|custom):
    1. create volume(1)
    2. write data to volume(1)
    3. create a kubernetes `VolumeSnapshot` object
       the `VolumeSnapshot.uuid` will be used to identify a
       **longhorn snapshot** and the associated `VolumeSnapshotContent` object
    4. check creation of a new longhorn snapshot named `snapshot-uuid`
    5. check for `VolumeSnapshotContent` named `snapcontent-uuid`
    6. wait for `VolumeSnapshotContent.readyToUse` flag to be set to **true**
    7. check for backup existance on the backupstore

    # the csi snapshot restore sets the fromBackup field same as
    # the StorageClass based restore approach.
    def csi_volumesnapshot_restore_test():
    8. create a `PersistentVolumeClaim` object where the `dataSource` field
       references the `VolumeSnapshot` object by name
    9. verify creation of a new volume(2) bound to the pvc created in step(8)
    10. verify data of new volume(2) equals data
        from backup (ie old data above)

    # default longhorn snapshot class is set to Delete
    # add a second test with a custom snapshot class with deletionPolicy
    # set to Retain you can reuse these methods for that and other tests
    def csi_volumesnapshot_deletion_test(deletionPolicy=&#39;Delete|Retain&#39;):
    11. delete `VolumeSnapshot` object
    12. if deletionPolicy == Delete:
        13. verify deletion of `VolumeSnapshot` and
            `VolumeSnapshotContent` objects
        14. verify deletion of backup from backupstore
    12. if deletionPolicy == Retain:
        13. verify deletion of `VolumeSnapshot`
        14. verify retention of `VolumeSnapshotContent`
            and backup on backupstore

    15. cleanup
    &#34;&#34;&#34;

    csisnapclass = \
        volumesnapshotclass(name=&#34;snapshotclass&#34;,
                            deletepolicy=volsnapshotclass_delete_policy,
                            snapshot_type=csi_snapshot_type)

    pod_name, pv_name, pvc_name, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api,
                                    csi_pv, pvc, pod_make,
                                    volume_name,
                                    data_path=&#34;/data/test&#34;)

    # Create volumeSnapshot test
    csivolsnap = volumesnapshot(volume_name + &#34;-volumesnapshot&#34;,
                                &#34;default&#34;,
                                csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                                &#34;persistentVolumeClaimName&#34;,
                                pvc_name)

    volume = client.by_id_volume(volume_name)

    for i in range(RETRY_COUNTS):
        snapshots = volume.snapshotList()
        if len(snapshots) == 2:
            break
        time.sleep(RETRY_INTERVAL)

    lh_snapshot = None
    snapshots = volume.snapshotList()
    for snapshot in snapshots:
        if snapshot[&#34;name&#34;] == &#34;snapshot-&#34; + csivolsnap[&#34;metadata&#34;][&#34;uid&#34;]:
            lh_snapshot = snapshot
    assert lh_snapshot is not None

    wait_for_volumesnapshot_ready(csivolsnap[&#34;metadata&#34;][&#34;name&#34;],
                                  csivolsnap[&#34;metadata&#34;][&#34;namespace&#34;])

    bv1, b = find_backup(client, volume_name, lh_snapshot[&#34;name&#34;])

    assert b[&#34;snapshotName&#34;] == lh_snapshot[&#34;name&#34;]

    restore_pvc_name = pvc[&#34;metadata&#34;][&#34;name&#34;] + &#34;-restore&#34;
    restore_pvc_size = pvc[&#34;spec&#34;][&#34;resources&#34;][&#34;requests&#34;][&#34;storage&#34;]

    restore_csi_volume_snapshot(core_api,
                                client,
                                csivolsnap,
                                restore_pvc_name,
                                restore_pvc_size)

    restore_pod = pod_make()
    restore_pod_name = restore_pod[&#34;metadata&#34;][&#34;name&#34;]
    restore_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(restore_pvc_name)]

    create_and_wait_pod(core_api, restore_pod)
    restore_md5sum = \
        get_pod_data_md5sum(core_api, restore_pod_name, path=&#34;/data/test&#34;)
    assert restore_md5sum == md5sum

    # Delete volumeSnapshot test
    delete_volumesnapshot(csivolsnap[&#34;metadata&#34;][&#34;name&#34;], &#34;default&#34;)

    if backup_is_deleted is False:
        find_backup(client, volume_name, b[&#34;snapshotName&#34;])
    else:
        wait_for_backup_delete(client, volume_name, b[&#34;name&#34;])</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.test_csi_volumesnapshot_restore_existing_backup"><code class="name flex">
<span>def <span class="ident">test_csi_volumesnapshot_restore_existing_backup</span></span>(<span>set_random_backupstore, client, core_api, volume_name, csi_pv, pvc, pod_make, volumesnapshotclass, volumesnapshotcontent, volumesnapshot, volsnapshotclass_delete_policy, backup_is_deleted)</span>
</code></dt>
<dd>
<div class="desc"><p>Test retention of a backup while deleting the associated <code>VolumeSnapshot</code>
via the csi snapshotter</p>
<p>Context:</p>
<p>We want to allow the user to programmatically create/restore/delete
longhorn backups via the csi snapshot mechanism
ref: <a href="https://kubernetes.io/docs/concepts/storage/volume-snapshots/">https://kubernetes.io/docs/concepts/storage/volume-snapshots/</a></p>
<p>Setup:</p>
<ol>
<li>Make sure your cluster contains the below crds
<a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a>
/tree/master/client/config/crd</li>
<li>Make sure your cluster contains the snapshot controller
<a href="https://github.com/kubernetes-csi/external-snapshotter">https://github.com/kubernetes-csi/external-snapshotter</a>
/tree/master/deploy/kubernetes/snapshot-controller</li>
</ol>
<p>Steps:</p>
<ol>
<li>create new snapshotClass with deletionPolicy set to Retain</li>
<li>call csi_volumesnapshot_creation_test(snapshotClass=custom)</li>
<li>call csi_volumesnapshot_restore_test()</li>
<li>call csi_volumesnapshot_deletion_test(deletionPolicy='Retain'):</li>
<li>cleanup</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(&#34;volsnapshotclass_delete_policy,backup_is_deleted&#34;, [(&#34;Delete&#34;, True), (&#34;Retain&#34;, False)]) # NOQA
def test_csi_volumesnapshot_restore_existing_backup(set_random_backupstore, # NOQA
                                                    client, # NOQA
                                                    core_api, # NOQA
                                                    volume_name, # NOQA
                                                    csi_pv, # NOQA
                                                    pvc, # NOQA
                                                    pod_make, # NOQA
                                                    volumesnapshotclass, # NOQA
                                                    volumesnapshotcontent,
                                                    volumesnapshot, # NOQA
                                                    volsnapshotclass_delete_policy, # NOQA
                                                    backup_is_deleted): # NOQA
    &#34;&#34;&#34;
    Test retention of a backup while deleting the associated `VolumeSnapshot`
    via the csi snapshotter

    Context:

    We want to allow the user to programmatically create/restore/delete
    longhorn backups via the csi snapshot mechanism
    ref: https://kubernetes.io/docs/concepts/storage/volume-snapshots/

    Setup:

    1. Make sure your cluster contains the below crds
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/client/config/crd
    2. Make sure your cluster contains the snapshot controller
    https://github.com/kubernetes-csi/external-snapshotter
    /tree/master/deploy/kubernetes/snapshot-controller

    Steps:

    1. create new snapshotClass with deletionPolicy set to Retain
    2. call csi_volumesnapshot_creation_test(snapshotClass=custom)
    3. call csi_volumesnapshot_restore_test()
    4. call csi_volumesnapshot_deletion_test(deletionPolicy=&#39;Retain&#39;):
    5. cleanup
    &#34;&#34;&#34;
    csisnapclass = \
        volumesnapshotclass(name=&#34;snapshotclass&#34;,
                            deletepolicy=volsnapshotclass_delete_policy)

    pod_name, pv_name, pvc_name, md5sum = \
        prepare_pod_with_data_in_mb(client, core_api,
                                    csi_pv, pvc, pod_make,
                                    volume_name,
                                    data_path=&#34;/data/test&#34;)

    volume = client.by_id_volume(volume_name)
    snap = create_snapshot(client, volume_name)
    volume.snapshotBackup(name=snap.name)
    wait_for_backup_completion(client, volume_name, snap.name)
    bv, b = find_backup(client, volume_name, snap.name)

    csivolsnap_name = volume_name + &#34;-volumesnapshot&#34;
    csivolsnap_namespace = &#34;default&#34;

    volsnapcontent = \
        volumesnapshotcontent(&#34;volsnapcontent&#34;,
                              csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                              &#34;Delete&#34;,
                              &#34;bs://&#34; + volume_name + &#34;/&#34; + b.name,
                              csivolsnap_name,
                              csivolsnap_namespace)

    csivolsnap = volumesnapshot(csivolsnap_name,
                                csivolsnap_namespace,
                                csisnapclass[&#34;metadata&#34;][&#34;name&#34;],
                                &#34;volumeSnapshotContentName&#34;,
                                volsnapcontent[&#34;metadata&#34;][&#34;name&#34;])

    restore_pvc_name = pvc[&#34;metadata&#34;][&#34;name&#34;] + &#34;-restore&#34;
    restore_pvc_size = pvc[&#34;spec&#34;][&#34;resources&#34;][&#34;requests&#34;][&#34;storage&#34;]

    restore_csi_volume_snapshot(core_api,
                                client,
                                csivolsnap,
                                restore_pvc_name,
                                restore_pvc_size)

    restore_pod = pod_make()
    restore_pod_name = restore_pod[&#34;metadata&#34;][&#34;name&#34;]
    restore_pod[&#39;spec&#39;][&#39;volumes&#39;] = [create_pvc_spec(restore_pvc_name)]

    create_and_wait_pod(core_api, restore_pod)
    restore_md5sum = \
        get_pod_data_md5sum(core_api, restore_pod_name, path=&#34;/data/test&#34;)

    assert restore_md5sum == md5sum

    # Delete volumeSnapshot test
    delete_volumesnapshot(csivolsnap[&#34;metadata&#34;][&#34;name&#34;], &#34;default&#34;)

    if backup_is_deleted is False:
        find_backup(client, volume_name, b[&#34;snapshotName&#34;])
    else:
        wait_for_backup_delete(client, volume_name, b[&#34;name&#34;])</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.volumesnapshot"><code class="name flex">
<span>def <span class="ident">volumesnapshot</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture
def volumesnapshot(request):
    class VolumeSnapshotFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshot(name,
                                  namespace,
                                  volumesnapshotclass_name,
                                  source_type,
                                  source_name):
            manifest = {
                &#39;apiVersion&#39;: &#39;snapshot.storage.k8s.io/v1beta1&#39;,
                &#39;kind&#39;: &#39;VolumeSnapshot&#39;,
                &#39;metadata&#39;: {
                  &#39;name&#39;: name,
                  &#39;namespace&#39;: namespace,
                },
                &#39;spec&#39;: {
                  &#39;volumeSnapshotClassName&#39;: volumesnapshotclass_name,
                  &#39;source&#39;: {
                    source_type: source_name
                  }
                }
            }

            VolumeSnapshotFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
            name = manifest[&#34;metadata&#34;][&#34;name&#34;]
            plural = &#34;volumesnapshots&#34;

            try:
                api.create_namespaced_custom_object(group=api_group,
                                                    version=api_version,
                                                    namespace=namespace,
                                                    plural=plural,
                                                    body=manifest)
            except ApiException as e:
                print(&#34;exception create volumesnapshot %s\n&#34; % e)

            for i in range(RETRY_COUNTS):
                status = \
                    api.get_namespaced_custom_object_status(
                            group=api_group,
                            version=api_version,
                            namespace=namespace,
                            plural=plural,
                            name=name)
                if &#34;status&#34; in status:
                    if &#34;boundVolumeSnapshotContentName&#34; in status[&#34;status&#34;]:
                        break
                time.sleep(RETRY_INTERVAL)

            return status

    yield VolumeSnapshotFactory.create_volumesnapshot

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotFactory.manifests:
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        namespace = manifest[&#34;metadata&#34;][&#34;namespace&#34;]
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        plural = &#34;volumesnapshots&#34;

        try:
            api.delete_namespaced_custom_object(group=api_group,
                                                version=api_version,
                                                namespace=namespace,
                                                plural=plural,
                                                name=name)
        except ApiException as e:
            assert e.status == 404</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.volumesnapshotclass"><code class="name flex">
<span>def <span class="ident">volumesnapshotclass</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture
def volumesnapshotclass(request):
    class VolumeSnapshotClassFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshotclass(name, deletepolicy, snapshot_type=None):
            manifest = {
                &#39;kind&#39;: &#39;VolumeSnapshotClass&#39;,
                &#39;apiVersion&#39;: &#39;snapshot.storage.k8s.io/v1beta1&#39;,
                &#39;metadata&#39;: {
                  &#39;name&#39;: name
                },
                &#39;driver&#39;: &#39;driver.longhorn.io&#39;,
                &#39;deletionPolicy&#39;: deletepolicy
            }

            if snapshot_type is not None:
                manifest.update({&#39;parameters&#39;: {&#39;type&#39;: snapshot_type}})

            VolumeSnapshotClassFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            manifest_api_version = manifest[&#34;apiVersion&#34;]

            api_group = urlparse(manifest_api_version).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest_api_version).path.split(&#34;/&#34;)[1]
            plural = &#34;volumesnapshotclasses&#34;

            try:
                api.create_cluster_custom_object(group=api_group,
                                                 version=api_version,
                                                 plural=plural,
                                                 body=manifest)
            except ApiException as e:
                print(&#34;exception creating volumesnapshotclass %s\n&#34; % e)

            return manifest

    yield VolumeSnapshotClassFactory.create_volumesnapshotclass

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotClassFactory.manifests:
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        plural = &#34;volumesnapshotclasses&#34;

        try:
            api.delete_cluster_custom_object(group=api_group,
                                             version=api_version,
                                             plural=plural,
                                             name=name)
        except ApiException as e:
            assert e.status == 404</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.volumesnapshotcontent"><code class="name flex">
<span>def <span class="ident">volumesnapshotcontent</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture
def volumesnapshotcontent(request):
    class VolumeSnapshotContentFactory():
        manifests = []

        @staticmethod
        def create_volumesnapshotcontent(name,
                                         volumesnapshotclass_name,
                                         delete_policy,
                                         snapshot_handle,
                                         volumesnapshot_ref_name,
                                         volumesnapshot_ref_namespace):
            manifest = {
                &#34;apiVersion&#34;: &#34;snapshot.storage.k8s.io/v1beta1&#34;,
                &#34;kind&#34;: &#34;VolumeSnapshotContent&#34;,
                &#34;metadata&#34;: {
                  &#34;name&#34;: name,
                },
                &#34;spec&#34;: {
                  &#34;volumeSnapshotClassName&#34;: volumesnapshotclass_name,
                  &#34;driver&#34;: &#34;driver.longhorn.io&#34;,
                  &#34;deletionPolicy&#34;: delete_policy,
                  &#34;source&#34;: {
                    &#34;snapshotHandle&#34;: snapshot_handle
                  },
                  &#34;volumeSnapshotRef&#34;: {
                    &#34;name&#34;: volumesnapshot_ref_name,
                    &#34;namespace&#34;: volumesnapshot_ref_namespace
                  }
                }
              }

            VolumeSnapshotContentFactory.manifests.append(manifest)

            api = get_custom_object_api_client()

            api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
            api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
            name = manifest[&#34;metadata&#34;][&#34;name&#34;]
            plural = &#34;volumesnapshotcontents&#34;

            try:
                api.create_cluster_custom_object(group=api_group,
                                                 version=api_version,
                                                 plural=plural,
                                                 body=manifest)
            except ApiException as e:
                print(&#34;exception create volumesnapshotcontent %s\n&#34; % e)

            for i in range(RETRY_COUNTS):
                status = \
                    api.get_cluster_custom_object_status(group=api_group,
                                                         version=api_version,
                                                         plural=plural,
                                                         name=name)
                if &#34;status&#34; in status:
                    if status[&#34;status&#34;][&#34;readyToUse&#34;] is True:
                        break
                time.sleep(RETRY_INTERVAL)

            return status

    yield VolumeSnapshotContentFactory.create_volumesnapshotcontent

    api = get_custom_object_api_client()

    for manifest in VolumeSnapshotContentFactory.manifests:
        api_group = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[0]
        api_version = urlparse(manifest[&#34;apiVersion&#34;]).path.split(&#34;/&#34;)[1]
        name = manifest[&#34;metadata&#34;][&#34;name&#34;]
        plural = &#34;volumesnapshotcontents&#34;

        try:
            api.delete_cluster_custom_object(group=api_group,
                                             version=api_version,
                                             plural=plural,
                                             name=name)
        except ApiException as e:
            assert e.status == 404</code></pre>
</details>
</dd>
<dt id="tests.test_csi_snapshotter.wait_for_volumesnapshot_ready"><code class="name flex">
<span>def <span class="ident">wait_for_volumesnapshot_ready</span></span>(<span>volumesnapshot_name, namespace)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_volumesnapshot_ready(volumesnapshot_name, namespace):
    api = get_custom_object_api_client()
    api_group = &#34;snapshot.storage.k8s.io&#34;
    api_version = &#34;v1beta1&#34;
    plural = &#34;volumesnapshots&#34;

    for i in range(RETRY_COUNTS):
        v = api.get_namespaced_custom_object_status(group=api_group,
                                                    version=api_version,
                                                    namespace=namespace,
                                                    plural=plural,
                                                    name=volumesnapshot_name)

        if v[&#34;status&#34;][&#34;readyToUse&#34;] is True:
            break

        time.sleep(RETRY_INTERVAL)

    assert v[&#34;status&#34;][&#34;readyToUse&#34;] is True
    return v</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tests" href="index.html">tests</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tests.test_csi_snapshotter.delete_volumesnapshot" href="#tests.test_csi_snapshotter.delete_volumesnapshot">delete_volumesnapshot</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.get_volumesnapshotcontent" href="#tests.test_csi_snapshotter.get_volumesnapshotcontent">get_volumesnapshotcontent</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.restore_csi_volume_snapshot" href="#tests.test_csi_snapshotter.restore_csi_volume_snapshot">restore_csi_volume_snapshot</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.test_csi_snapshot_with_bak_param" href="#tests.test_csi_snapshotter.test_csi_snapshot_with_bak_param">test_csi_snapshot_with_bak_param</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.test_csi_snapshot_with_invalid_param" href="#tests.test_csi_snapshotter.test_csi_snapshot_with_invalid_param">test_csi_snapshot_with_invalid_param</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.test_csi_snapshot_with_snap_param" href="#tests.test_csi_snapshotter.test_csi_snapshot_with_snap_param">test_csi_snapshot_with_snap_param</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.test_csi_volumesnapshot_basic" href="#tests.test_csi_snapshotter.test_csi_volumesnapshot_basic">test_csi_volumesnapshot_basic</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.test_csi_volumesnapshot_restore_existing_backup" href="#tests.test_csi_snapshotter.test_csi_volumesnapshot_restore_existing_backup">test_csi_volumesnapshot_restore_existing_backup</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.volumesnapshot" href="#tests.test_csi_snapshotter.volumesnapshot">volumesnapshot</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.volumesnapshotclass" href="#tests.test_csi_snapshotter.volumesnapshotclass">volumesnapshotclass</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.volumesnapshotcontent" href="#tests.test_csi_snapshotter.volumesnapshotcontent">volumesnapshotcontent</a></code></li>
<li><code><a title="tests.test_csi_snapshotter.wait_for_volumesnapshot_ready" href="#tests.test_csi_snapshotter.wait_for_volumesnapshot_ready">wait_for_volumesnapshot_ready</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>